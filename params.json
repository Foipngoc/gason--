{"name":"gason++","tagline":"an efficient Json parser and builder in plain C++","body":"# gason++\r\n\r\ngason++ is a light tweak for [gason](https://github.com/vivkin/gason) parser to make its usage even simpler for end-users.\r\nThere is also a simple JSon builder tool.\r\n\r\ngason is an **efficient** and fantastic JSon parser in plain C++ with minimum dependency by [vivkin](https://github.com/vivkin).\r\n\r\nplease read gason documents to see the full list of features and other notes.\r\n\r\n## Table of Contents\r\n- [Notes](#notes)\r\n- [Installation](#installation)\r\n- [Usage](#usage)\r\n    - [Parsing](#parsing)\r\n    - [Child elements](#child-elements)\r\n    - [Type checking](#type-checking)\r\n    - [Conversion](#conversion)\r\n    - [Iteration](#iteration)\r\n    - [Building](#building)\r\n- [License](#license)\r\n\r\n## Notes\r\n[TOC](#table-of-contents)\r\n\r\ngason(gason++) is efficient and fast and it does not consume any extra memory for parsed values (objects, arrays, ...)\r\n\r\n* gason(gason++) is a **destructive** parser:\r\n> your *source buffer* will be **modified**! and this buffer is the only place where the values do exist.\r\n\r\n* there is a simple and efficient `JSonBuilder` which is not present on original `gason`.\r\n\r\n* `c++11` is optional and `gason++` is also compilable on older toolchains. `gason` requires `c++11`.\r\n\r\n* `JsonAllocator` is **reusable** and **auto-expandable** in `gason++` and the implementation does not free/alloc memory with every `jsonParse()` (this is not the case in `gason`). for more information see doxygen comments of `JsonAllocator` or [sample:parser](./tests/parser1/main.cpp) \r\n\r\n\r\n## Installation\r\n[TOC](#table-of-contents)\r\n\r\nDownload latest version and just add [gason.hpp](./src/gason.hpp) / [gason.cpp](./src/gason.cpp) and [jsonbuilder.hpp](./src/jsonbuilder.hpp) from [src](./src) folder into your project tree.\r\n\r\nOther `*.pro` and source files are just for testing purpose.\r\n\r\n\r\n\r\n## Usage\r\n[TOC](#table-of-contents)\r\n\r\nsuppose this json:\r\n```json\r\n{\r\n  \"an_array\": [\r\n    10,\r\n    11,\r\n    12\r\n  ],\r\n  \"a_boolean\": true,\r\n  \"a_null\": null,\r\n  \"a_number\": 123,\r\n  \"an_object\": {\r\n    \"a\": \"b\",\r\n    \"c\": \"d\",\r\n    \"e\": \"f\"\r\n  },\r\n  \"a_message\": \"Hello World\"\r\n}\r\n```\r\n\r\n### Parsing\r\n[TOC](#table-of-contents)\r\n\r\nto parse it simply do:\r\n```cpp\r\n// this buffer holds the json content.\r\n// char *jsonString;\r\n\r\ngason::JsonAllocator    allocator;\r\ngason::JsonValue        root;\r\ngason::JsonParseStatus  status = gason::jsonParse(jsonString, root, allocator);\r\n\r\nif ( status != gason::JSON_PARSE_OK ) {\r\n    puts(\"parsing failed!\");\r\n    // for more info check the status.\r\n    return false;\r\n}\r\n\r\n// hint: jsonString will be over-written by jsonParse()\r\n//        and you have to keep this buffer and allocator alive\r\n//        as long as the parsed JSon values are required.\r\n```\r\n\r\nsee [sample:parser](./tests/parser1/main.cpp) for more examples.\r\n\r\n### Child elements\r\n[TOC](#table-of-contents)\r\n\r\ngason++ introduces an easy API to retrieve the child elements:\r\n\r\n```cpp\r\ngason::JsonValue str  = root.child(\"a_message\");        // = Hello World\r\ngason::JsonValue arr0 = root.child(\"an_array\").at(0);   // = 10\r\n// short form\r\ngason::JsonValue arr2 = root(\"an_array\")[2];            // = 12\r\ngason::JsonValue objc = root(\"an_object\")(\"c\");         // = d\r\n```\r\n> All **values** will become **invalid** when **allocator** be **destroyed**.\r\n\r\n\r\n### Type checking\r\n[TOC](#table-of-contents)\r\n\r\nto check validity or the type of values:\r\n```cpp\r\nif ( !str ) {\r\n    puts(\"str is not a valid JsonValue!\");\r\n}\r\nif ( arr2    &&    arr2.isNumber() ) {\r\n    puts(\"a valid number has been found on an_array[2].\");\r\n}\r\nif ( objc    &&    objc.isString() ) {\r\n    puts(\"an string has been found in root->an_object->c.\");\r\n}\r\n```\r\n\r\n### Conversion\r\n[TOC](#table-of-contents)\r\n\r\n`JsonValue` has some `toXXX(bool *ok = nullptr)` to convert a value into an int, string, ...\r\n\r\nif conversion fails, the conversion methods:\r\n\r\n* fire `assert()` if `ok` is not specified (default).\r\n* return a `0`,`nullptr` or `false` value and `*ok` will be set to `false`.\r\n\r\n```cpp\r\nbool ok = false;\r\n\r\nint  invalidValue1 = str.toInt();   // will assert() and program aborts.\r\n\r\nconst char* invalidValue2 = arr2.toString(&ok); // won't assert()\r\nif ( !ok ) {\r\n    puts(\"arr2 is an int not a string!\");\r\n}\r\n```\r\n\r\n### Iteration\r\n[TOC](#table-of-contents)\r\n\r\nto iterate over children (elements) simply:\r\n```cpp\r\ngason::JsonValue obj = root(\"an_object\");\r\n\r\nfor ( gason::JsonIterator it =  gason::begin(obj); gason::end(obj); it++ ) {\r\n    printf(\"%s = %s\\n\", it->key, it->value.toString());\r\n}\r\n\r\n// or\r\ngason::JsonIterator it = gason::begin( obj );\r\nwhile ( it.isValid() ) {\r\n    printf(\"%s = %s\\n\", it->key, it->value.toString());\r\n\r\n    it++;\r\n}\r\n\r\n// both prints:\r\n// a = b\r\n// c = d\r\n// e = f\r\n```\r\n\r\n### Building\r\n[TOC](#table-of-contents)\r\n\r\nto build the above json:\r\n```cpp\r\nchar buffer[257] = {0};\r\ngason::JSonBuilder doc(buffer, 256);\r\n\r\ndoc.startObject()\r\n        .startArray(\"an_array\")\r\n            .addValue(10)\r\n            .addValue(11)\r\n            .addValue(12)\r\n        .endArray()\r\n\r\n        .addValue(\"a_boolean\", true)\r\n        .addNull(\"a_null\")\r\n        .addValue(\"a_number\", 123)\r\n\r\n        .startObject(\"an_object\")\r\n            .addValue(\"a\", \"b\")\r\n            .addValue(\"c\", \"d\")\r\n            .addValue(\"e\", \"f\")\r\n        .endObject()\r\n\r\n        .addValue(\"a_message\", \"Hello World\")\r\n\r\n        .endObject();\r\n\r\n// now the buffer contains the proper json string.\r\n\r\nif ( !doc.isBufferAdequate() ) {\r\n    puts(\"warning: the buffer is small and the output json is not valid.\");\r\n}\r\n```\r\n\r\n> JSonBuilder just makes **compact** form of JSon strings suitable for storage or network communications. (the output is not indented.)\r\n\r\nsee [sample:builder](./tests/builder1/main.cpp) for more examples.\r\n\r\n\r\n## License\r\n[TOC](#table-of-contents)\r\n\r\nDistributed under the MIT license. Copyright (c) 2014, Amir Zamani.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}